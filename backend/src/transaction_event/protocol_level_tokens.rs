use async_graphql::{SimpleObject, Union};
use concordium_rust_sdk::{
    base::protocol_level_tokens
    
};

use serde::{Deserialize, Serialize};

use crate::address::AccountAddress;
//  "name": "VNXAU1N",
// "burnable": true,
// "denyList": true,
// "metadata": "https://apricot-misleading-limpet-309.mypinata.cloud/ipfs/bafkreif6t6e2k66vxzftfjs5iekolcdynpn5r2fhbyzrznhmhdwlqymcda",
// "mintable": true,
// "allowList": true,
// "initialSupply": 4([-18, 2003764205206896640_3]),

#[derive(Debug,)]
pub struct InitializationParameters {
    /// The metadata URL for the token.
    pub metadata: String,
    /// The initial supply of the token.
    pub initial_supply: String,
    /// Whether the token is burnable.
    pub burnable: bool,
    /// Whether the token is mintable.
    pub mintable: bool,
    /// Whether the token has an allow list.
    pub allow_list: bool,
    /// Whether the token has a deny list.
    pub deny_list: bool,
}



#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct CreatePlt {
    /// The symbol of the token.
    pub token_id: String,
    /// A SHA256 hash that identifies the token module implementation.
    pub token_module: String,
    /// The address of the account that will govern the token.
    pub governance_account: AccountAddress,
    /// The number of decimal places used in the representation of amounts of
    /// this token. This determines the smallest representable fraction of the
    /// token.
    pub decimals: u8,
    /// The initialization parameters of the token, encoded in CBOR.
    pub initialization_parameters: serde_json::Value,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone)]
pub struct TokenCreationDetails {
    // The update payload used to create the token.
    pub create_plt: CreatePlt,
    // The events generated by the token module during the creation of the token.
    pub events: Vec<TokenEvent>,
}

/// Common event struct for both Holder and Governance events.
#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenEvent {
    pub token_id: String,
    pub event: TokenEventDetails,
}

/// Named struct for TokenHolderEvent.
#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenHolderEvent {
    pub token_id: String,
    pub event: TokenEventDetails,
}

/// Named struct for TokenGovernanceEvent.
#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenGovernanceEvent {
    pub token_id: String,
    pub event: TokenEventDetails,
}

/// Union for GraphQL API.
#[derive(Union, Serialize, Deserialize, Clone, Debug)]
pub enum TokenEventUnion {
    TokenHolder(TokenHolderEvent),
    TokenGovernance(TokenGovernanceEvent),
}

#[derive(Union, Serialize, Deserialize, Clone, Debug)]
pub enum TokenEventDetails {
    Module(TokenModuleEvent),
    Transfer(TokenTransferEvent),
    Mint(MintEvent),
    Burn(BurnEvent),
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenModuleEvent {
    pub event_type: String,
    pub details: TokenModuleEventType,
}

#[derive(Union, Serialize, Deserialize, Clone, Debug)]

pub enum TokenModuleEventType {
    AddAllowList(TokenListUpdateEventDetailsAddAllowList),
    RemoveAllowList(TokenListUpdateEventDetailsRemoveAllowList),
    AddDenyList(TokenListUpdateEventDetailsAddDenyList),
    RemoveDenyList(TokenListUpdateEventDetailsRemoveDenyList),
    Unknow(UnknownTokenListUpdateEventDetails),
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]

pub struct UnknownTokenListUpdateEventDetails {
    /// A message describing the unknown event.
    pub message: String,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenListUpdateEventDetails {
    /// The account that was added or removed from an allow or deny list
    pub target: TokenHolder,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenListUpdateEventDetailsAddAllowList {
    /// The account that was added or removed from an allow or deny list
    pub target: TokenHolder,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenListUpdateEventDetailsRemoveAllowList {
    /// The account that was added or removed from an allow or deny list
    pub target: TokenHolder,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenListUpdateEventDetailsAddDenyList {
    /// The account that was added or removed from an allow or deny list
    pub target: TokenHolder,
}
#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenListUpdateEventDetailsRemoveDenyList {
    /// The account that was added or removed from an allow or deny list
    pub target: TokenHolder,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenHolder {
    pub address: AccountAddress,
    pub coin_info: Option<String>,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenAmount {
    pub value: String,
    pub decimals: u8,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct Memo {
    pub bytes: String,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct TokenTransferEvent {
    pub from: TokenHolder,
    pub to: TokenHolder,
    pub amount: TokenAmount,
    pub memo: Option<Memo>,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct MintEvent {
    pub target: TokenHolder,
    pub amount: TokenAmount,
}

#[derive(SimpleObject, Serialize, Deserialize, Clone, Debug)]
pub struct BurnEvent {
    pub target: TokenHolder,
    pub amount: TokenAmount,
}

impl From<concordium_rust_sdk::protocol_level_tokens::TokenHolder> for TokenHolder {
    fn from(holder: concordium_rust_sdk::protocol_level_tokens::TokenHolder) -> Self {
        match holder {
            concordium_rust_sdk::protocol_level_tokens::TokenHolder::HolderAccount(acc) => Self {
                address: acc.address.into(),
                coin_info: acc.coin_info.map(|c| format!("{:?}", c)),
            },
        }
    }
}

impl From<concordium_rust_sdk::protocol_level_tokens::TokenAmount> for TokenAmount {
    fn from(amount: concordium_rust_sdk::protocol_level_tokens::TokenAmount) -> Self {
        Self {
            value: amount.to_string(),
            decimals: amount.decimals(),
        }
    }
}

impl From<concordium_rust_sdk::types::Memo> for Memo {
    fn from(memo: concordium_rust_sdk::types::Memo) -> Self {
        Self {
            bytes: hex::encode(memo.as_ref()),
        }
    }
}

impl From<concordium_rust_sdk::protocol_level_tokens::TokenEventDetails> for TokenEventDetails {
    fn from(event: concordium_rust_sdk::protocol_level_tokens::TokenEventDetails) -> Self {
        use concordium_rust_sdk::protocol_level_tokens::TokenEventDetails as TokenEventDetailsType;
        match event {
            TokenEventDetailsType::Module(e) => TokenEventDetails::Module(TokenModuleEvent {
                event_type: e.event_type.as_ref().to_string(),
                details: {
                    match protocol_level_tokens::TokenModuleEvent::decode_token_module_event(&e) {
                        Ok(event_type) => event_type.into(),
                        Err(e) => {
                            TokenModuleEventType::Unknow(UnknownTokenListUpdateEventDetails {
                                message: format!("Failed to decode token module event: {}", e),
                            })
                        }
                    }
                },
            }),
            TokenEventDetailsType::Transfer(e) => TokenEventDetails::Transfer(TokenTransferEvent {
                from: e.from.into(),
                to: e.to.into(),
                amount: e.amount.into(),
                memo: e.memo.map(Into::into),
            }),
            TokenEventDetailsType::Mint(e) => TokenEventDetails::Mint(MintEvent {
                target: e.target.into(),
                amount: e.amount.into(),
            }),
            TokenEventDetailsType::Burn(e) => TokenEventDetails::Burn(BurnEvent {
                target: e.target.into(),
                amount: e.amount.into(),
            }),
        }
    }
}

// impl From TokenModuleEventType
impl From<concordium_rust_sdk::protocol_level_tokens::TokenModuleEventType>
    for TokenModuleEventType
{
    fn from(event_type: concordium_rust_sdk::protocol_level_tokens::TokenModuleEventType) -> Self {
        match event_type {
            concordium_rust_sdk::protocol_level_tokens::TokenModuleEventType::AddAllowList(
                details,
            ) => TokenModuleEventType::AddAllowList(TokenListUpdateEventDetailsAddAllowList {
                target: details.target.into(),
            }),
            concordium_rust_sdk::protocol_level_tokens::TokenModuleEventType::RemoveAllowList(
                details,
            ) => {
                TokenModuleEventType::RemoveAllowList(TokenListUpdateEventDetailsRemoveAllowList {
                    target: details.target.into(),
                })
            }
            concordium_rust_sdk::protocol_level_tokens::TokenModuleEventType::AddDenyList(
                details,
            ) => TokenModuleEventType::AddDenyList(TokenListUpdateEventDetailsAddDenyList {
                target: details.target.into(),
            }),
            concordium_rust_sdk::protocol_level_tokens::TokenModuleEventType::RemoveDenyList(
                details,
            ) => TokenModuleEventType::RemoveDenyList(TokenListUpdateEventDetailsRemoveDenyList {
                target: details.target.into(),
            }),
            _ => TokenModuleEventType::Unknow(UnknownTokenListUpdateEventDetails {
                message: "Unknown token module event type".to_string(),
            }),
        }
    }
}

impl CreatePlt {
    pub async fn save(
        &self,
        tx: &mut sqlx::PgTransaction<'_>,
        transaction_index: i64,
    ) -> anyhow::Result<()> {
        println!("========================");
        println!("Self: {:?}", self);
        println!("========================");
        println!("tx: {:?}", tx);
        println!("transaction_index: {:?}", transaction_index);

        // Replace `SomeType` with the actual type you expect to decode.
        // For example, if you expect a serde_json::Value, use that, or use the appropriate struct.
        // println!("Initialization parameters cbor decoded: {:?}", cbor_decode::<serde_json::Value>(self.initialization_parameters.to_string().as_bytes()));

        // sqlx::query!(
        //     "INSERT INTO plt_creations (id, transaction_index, token_id, token_module, governance_account, decimals, initialization_parameters) VALUES (
        //         (SELECT COALESCE(MAX(id) + 1, 0) FROM plt_creations),
        //         $1,
        //         $2,
        //         $3,
        //         $4,
        //         $5,
        //         $6
        //     )",
        //     transaction_index.clone(),
        //     self.token_id,
        //     self.token_module,
        //     self.governance_account.to_string(),
        //     self.decimals as i16,
        //     serde_json::to_value(&self.initialization_parameters).unwrap(),
        // )
        // .execute(tx.as_mut())
        // .await?
        // .rows_affected();

        Ok(())
    }
}

impl TokenEvent {
    /// Converts a protocol-level token event into a common event structure.
    pub fn prepare(
        event: &concordium_rust_sdk::protocol_level_tokens::TokenEvent,
    ) -> anyhow::Result<Self> {
        Ok(TokenEvent {
            token_id: event.token_id.clone().into(),
            event: event.event.clone().into(),
        })
    }
    pub async fn save(
        &self,
        tx: &mut sqlx::PgTransaction<'_>,
        transaction_index: i64,
    ) -> anyhow::Result<()> {
        println!("========================");
        println!("Self: {:?}", self);
        println!("========================");
        println!("tx: {:?}", tx);
        println!("transaction_index: {:?}", transaction_index);
        let token_id = self.token_id.clone();
        match &self.event {
            TokenEventDetails::Module(details) => {
                let token_id = self.token_id.clone();
                let event_type = details.event_type.clone();
                // The match arms below return different types, which is not allowed.
                // If you need to handle each variant, do so without assigning to a single variable of a concrete type.
                let event_details: TokenModuleEventType = match &details.details {
                    TokenModuleEventType::AddAllowList(details) => {
                        TokenModuleEventType::AddAllowList(
                            TokenListUpdateEventDetailsAddAllowList {
                                target: details.target.clone(),
                            },
                        )
                    }
                    TokenModuleEventType::RemoveAllowList(details) => {
                        TokenModuleEventType::RemoveAllowList(
                            TokenListUpdateEventDetailsRemoveAllowList {
                                target: details.target.clone(),
                            },
                        )
                    }
                    TokenModuleEventType::AddDenyList(details) => {
                        TokenModuleEventType::AddDenyList(TokenListUpdateEventDetailsAddDenyList {
                            target: details.target.clone(),
                        })
                    }
                    TokenModuleEventType::RemoveDenyList(details) => {
                        TokenModuleEventType::RemoveDenyList(
                            TokenListUpdateEventDetailsRemoveDenyList {
                                target: details.target.clone(),
                            },
                        )
                    }
                    TokenModuleEventType::Unknow(details) => {
                        TokenModuleEventType::Unknow(UnknownTokenListUpdateEventDetails {
                            message: details.message.clone(),
                        })
                    }
                };

                sqlx::query!(
                    "INSERT INTO plt_events (id, transaction_index, event_type, token_module_type, token_id, token_event) VALUES (
                        (SELECT COALESCE(MAX(id) + 1, 0) FROM plt_events),
                        $1,
                        'TokenModule',
                        'AddAllowList',
                        $2,
                        $3
                        
                    )",
                    transaction_index.clone(),
                    token_id,
                    serde_json::to_value(details).unwrap(),
                ).execute(tx.as_mut())
                .await?
                .rows_affected();
            }
            TokenEventDetails::Transfer(token_transfer_event) => {
                let from_address = token_transfer_event.from.address.clone();
                let to_address = token_transfer_event.to.address.clone();
                let amount_value = token_transfer_event.amount.value.clone();
                let amount_decimals = token_transfer_event.amount.decimals;
                let memo_bytes = token_transfer_event.memo.as_ref().map(|m| m.bytes.clone());

                sqlx::query!(
                    "INSERT INTO plt_events (id, transaction_index, event_type, token_id, token_event) VALUES (
                        (SELECT COALESCE(MAX(id) + 1, 0) FROM plt_events),
                        $1,
                        'Transfer',
                        $2,
                        $3
                    )",
                    transaction_index.clone(),
                    token_id,
                    serde_json::to_value(token_transfer_event).unwrap(),
                ).execute(tx.as_mut())
                .await?
                .rows_affected();
            }
            TokenEventDetails::Mint(mint_event) => {
                let target_address = mint_event.target.address.clone();
                let amount_value = mint_event.amount.value.clone();
                let amount_decimals = mint_event.amount.decimals;
                sqlx::query!(
                    "INSERT INTO plt_events (id, transaction_index, event_type, token_id, token_event) VALUES (
                        (SELECT COALESCE(MAX(id) + 1, 0) FROM plt_events),
                        $1,
                        'Mint',
                        $2,
                        $3
                    )",
                    transaction_index.clone(),
                    token_id,
                    serde_json::to_value(mint_event).unwrap(),
                ).execute(tx.as_mut())
                .await?
                .rows_affected();
            }
            TokenEventDetails::Burn(burn_event) => {
                let target_address = burn_event.target.address.clone();
                let amount_value = burn_event.amount.value.clone();
                let amount_decimals = burn_event.amount.decimals;
                // sqlx::query!(
                //     "INSERT INTO plt_events (id, transaction_index, event_type, token_id, token_event) VALUES (
                //         (SELECT COALESCE(MAX(id) + 1, 0) FROM plt_events),
                //         $1,
                //         'Burn',
                //         $2,
                //         $3
                //     )",
                //     transaction_index.clone(),
                //     token_id,
                //     serde_json::to_value(burn_event).unwrap(),
                // ).execute(tx.as_mut())
                // .await?
                // .rows_affected();
            }
        };

        Ok(())
    }
}

// Optionally, implement From<TokenEvent> for the wrappers for ergonomic
// construction:
impl From<TokenEvent> for TokenHolderEvent {
    fn from(common: TokenEvent) -> Self {
        TokenHolderEvent {
            token_id: common.token_id,
            event: common.event,
        }
    }
}
impl From<TokenEvent> for TokenGovernanceEvent {
    fn from(common: TokenEvent) -> Self {
        TokenGovernanceEvent {
            token_id: common.token_id,
            event: common.event,
        }
    }
}
