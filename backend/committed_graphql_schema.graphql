schema {
  query: Query
  subscription: Subscription
}

type Account {
  releaseSchedule: AccountReleaseSchedule!
  transactions("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): AccountTransactionRelationConnection
  accountStatement("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): AccountStatementEntryConnection
  id: ID!
  address: AccountAddress!
  addressString: String! @deprecated(reason: "Use 'address.asString' instead. This field will be removed in the near future.")
  amount: UnsignedLong!
  transactionCount: Int!
  createdAt: DateTime!
}

type AccountAddress {
  asString: String!
}

type AccountCreated {
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type AccountReleaseSchedule {
  schedule("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): AccountReleaseScheduleItemConnection
  totalAmount: UnsignedLong!
}

type AccountReleaseScheduleItem {
  transaction: Transaction!
  timestamp: DateTime!
  amount: UnsignedLong!
}

"A connection to a list of items."
type AccountReleaseScheduleItemConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [AccountReleaseScheduleItemEdge!]
  "A flattened list of the nodes."
  nodes: [AccountReleaseScheduleItem!]
}

"An edge in a connection."
type AccountReleaseScheduleItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AccountReleaseScheduleItem!
}

type AccountStatementEntry {
  reference: BlockOrTransaction!
  timestamp: DateTime!
  entryType: AccountStatementEntryType!
  amount: Long!
  accountBalance: UnsignedLong!
}

"A connection to a list of items."
type AccountStatementEntryConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [AccountStatementEntryEdge!]
  "A flattened list of the nodes."
  nodes: [AccountStatementEntry!]
}

"An edge in a connection."
type AccountStatementEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AccountStatementEntry!
}

type AccountTransaction {
  accountTransactionType: AccountTransactionType
}

type AccountTransactionRelation {
  transaction: Transaction!
}

"A connection to a list of items."
type AccountTransactionRelationConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [AccountTransactionRelationEdge!]
  "A flattened list of the nodes."
  nodes: [AccountTransactionRelation!]
}

"An edge in a connection."
type AccountTransactionRelationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AccountTransactionRelation!
}

"A connection to a list of items."
type AccountsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [AccountsEdge!]
  "A flattened list of the nodes."
  nodes: [Account!]
}

"An edge in a connection."
type AccountsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Account!
}

type AccountsMetrics {
  "Total number of accounts created (all time)"
  lastCumulativeAccountsCreated: Long!
  "Total number of accounts created in requested period."
  accountsCreated: Int!
  buckets: AccountsMetricsBuckets!
}

type AccountsMetricsBuckets {
  "The width (time interval) of each bucket."
  bucketWidth: TimeSpan!
  "Start of the bucket time period. Intended x-axis value."
  x_Time: [DateTime!]!
  "Total number of accounts created (all time) at the end of the bucket period. Intended y-axis value."
  y_LastCumulativeAccountsCreated: [Long!]!
  "Number of accounts created within bucket time period. Intended y-axis value."
  y_AccountsCreated: [Int!]!
}

type AddAnonymityRevokerChainUpdatePayload {
  arIdentity: Int!
  name: String!
  url: String!
  description: String!
}

type AddIdentityProviderChainUpdatePayload {
  ipIdentity: Int!
  name: String!
  url: String!
  description: String!
}

type AlreadyABaker {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  bakerId: UnsignedLong!
}

type AmountAddedByDecryption {
  amount: UnsignedLong!
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type AmountTooLarge {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  address: Address!
  amount: UnsignedLong!
}

"A connection to a list of items."
type AmountsScheduleConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [AmountsScheduleEdge!]
  "A flattened list of the nodes."
  nodes: [TimestampedAmount!]
}

"An edge in a connection."
type AmountsScheduleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimestampedAmount!
}

type BakerAdded {
  stakedAmount: UnsignedLong!
  restakeEarnings: Boolean!
  bakerId: UnsignedLong!
  accountAddress: AccountAddress!
  signKey: String!
  electionKey: String!
  aggregationKey: String!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type BakerInCooldown {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type BakerKeysUpdated {
  bakerId: UnsignedLong!
  accountAddress: AccountAddress!
  signKey: String!
  electionKey: String!
  aggregationKey: String!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type BakerRemoved {
  bakerId: UnsignedLong!
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type BakerSetRestakeEarnings {
  bakerId: UnsignedLong!
  accountAddress: AccountAddress!
  restakeEarnings: Boolean!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type BakerStakeDecreased {
  bakerId: UnsignedLong!
  accountAddress: AccountAddress!
  newStakedAmount: UnsignedLong!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type BakerStakeIncreased {
  bakerId: UnsignedLong!
  accountAddress: AccountAddress!
  newStakedAmount: UnsignedLong!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type BakerStakeThresholdChainUpdatePayload {
  amount: UnsignedLong!
}

type BakingReward {
  amount: UnsignedLong!
  address: AccountAddress!
  addressString: String! @deprecated(reason: "Use 'address.asString' instead. This field will be removed in the near future.")
}

"A connection to a list of items."
type BakingRewardConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [BakingRewardEdge!]
  "A flattened list of the nodes."
  nodes: [BakingReward!]
}

"An edge in a connection."
type BakingRewardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BakingReward!
}

type BakingRewards {
  rewards("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): BakingRewardConnection
  remainder: UnsignedLong!
}

type BalanceStatistics {
  "The total CCD in existence"
  totalAmount: UnsignedLong!
  "The total CCD released according to the Concordium promise published on deck.concordium.com. Will be null for blocks with slot time before the published release schedule."
  totalAmountReleased: UnsignedLong
  "The total CCD in encrypted balances"
  totalEncryptedAmount: UnsignedLong!
  "The total CCD locked in release schedules (from transfers with schedule)"
  totalAmountLockedInReleaseSchedules: UnsignedLong!
  "The amount in the baking reward account"
  bakingRewardAccount: UnsignedLong!
  "The amount in the finalization reward account"
  finalizationRewardAccount: UnsignedLong!
  "The amount in the GAS account"
  gasAccount: UnsignedLong!
}

type Block {
  transactions("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): TransactionsConnection
  chainParameters: ChainParameters!
  id: ID!
  blockHash: String!
  blockHeight: Int!
  blockSlotTime: DateTime!
  bakerId: Int
  finalized: Boolean!
  transactionCount: Int!
  specialEvents: SpecialEvents!
  finalizationSummary: FinalizationSummary
  balanceStatistics: BalanceStatistics!
  blockStatistics: BlockStatistics!
}

type BlockMetrics {
  "The most recent block height. Equals the total length of the chain minus one (genesis block is at height zero)."
  lastBlockHeight: Long!
  "Total number of blocks added in requested period."
  blocksAdded: Int!
  "The average block time (slot-time difference between two adjacent blocks) in the requested period. Will be null if no blocks have been added in the requested period."
  avgBlockTime: Float
  "The average finalization time (slot-time difference between a given block and the block that holds its finalization proof) in the requested period. Will be null if no blocks have been finalized in the requested period."
  avgFinalizationTime: Float
  "The total amount of CCD in existence."
  lastTotalMicroCcd: Long!
  "The total amount of CCD in encrypted balances."
  lastTotalEncryptedMicroCcd: Long!
  buckets: BlockMetricsBuckets!
}

type BlockMetricsBuckets {
  "The width (time interval) of each bucket."
  bucketWidth: TimeSpan!
  "Start of the bucket time period. Intended x-axis value."
  x_Time: [DateTime!]!
  "Number of blocks added within the bucket time period. Intended y-axis value."
  y_BlocksAdded: [Int!]!
  "The minimum block time (slot-time difference between two adjacent blocks) in the bucket period. Intended y-axis value. Will be null if no blocks have been added in the bucket period."
  y_BlockTimeMin: [Float]!
  "The average block time (slot-time difference between two adjacent blocks) in the bucket period. Intended y-axis value. Will be null if no blocks have been added in the bucket period."
  y_BlockTimeAvg: [Float]!
  "The maximum block time (slot-time difference between two adjacent blocks) in the bucket period. Intended y-axis value. Will be null if no blocks have been added in the bucket period."
  y_BlockTimeMax: [Float]!
  "The minimum finalization time (slot-time difference between a given block and the block that holds its finalization proof) in the bucket period. Intended y-axis value. Will be null if no blocks have been finalized in the bucket period."
  y_FinalizationTimeMin: [Float]!
  "The average finalization time (slot-time difference between a given block and the block that holds its finalization proof) in the bucket period. Intended y-axis value. Will be null if no blocks have been finalized in the bucket period."
  y_FinalizationTimeAvg: [Float]!
  "The maximum finalization time (slot-time difference between a given block and the block that holds its finalization proof) in the bucket period. Intended y-axis value. Will be null if no blocks have been finalized in the bucket period."
  y_FinalizationTimeMax: [Float]!
  "The total amount of CCD in existence at the end of the bucket period. Intended y-axis value."
  y_LastTotalMicroCcd: [Long!]!
  "The minimum amount of CCD in encrypted balances in the bucket period. Intended y-axis value. Will be null if no blocks have been added in the bucket period."
  y_MinTotalEncryptedMicroCcd: [Long]!
  "The maximum amount of CCD in encrypted balances in the bucket period. Intended y-axis value. Will be null if no blocks have been added in the bucket period."
  y_MaxTotalEncryptedMicroCcd: [Long]!
  "The total amount of CCD in encrypted balances at the end of the bucket period. Intended y-axis value."
  y_LastTotalEncryptedMicroCcd: [Long!]!
}

type BlockRewards {
  transactionFees: UnsignedLong!
  oldGasAccount: UnsignedLong!
  newGasAccount: UnsignedLong!
  bakerReward: UnsignedLong!
  foundationCharge: UnsignedLong!
  bakerAccountAddress: AccountAddress!
  bakerAccountAddressString: String! @deprecated(reason: "Use 'bakerAccountAddress.asString' instead. This field will be removed in the near future.")
  foundationAccountAddress: AccountAddress!
  foundationAccountAddressString: String! @deprecated(reason: "Use 'foundationAccountAddressString' instead. This field will be removed in the near future.")
}

type BlockStatistics {
  blockTime: Float!
  finalizationTime: Float
}

"A connection to a list of items."
type BlocksConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [BlocksEdge!]
  "A flattened list of the nodes."
  nodes: [Block!]
}

"An edge in a connection."
type BlocksEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Block!
}

type ChainParameters {
  electionDifficulty: Decimal!
  euroPerEnergy: ExchangeRate!
  microCcdPerEuro: ExchangeRate!
  bakerCooldownEpochs: UnsignedLong!
  credentialsPerBlockLimit: Int!
  rewardParameters: RewardParameters!
  foundationAccountAddress: AccountAddress!
  minimumThresholdForBaking: UnsignedLong!
}

type ChainUpdateEnqueued {
  effectiveTime: DateTime!
  payload: ChainUpdatePayload!
}

type ContractAddress {
  index: UnsignedLong!
  subIndex: UnsignedLong!
  asString: String!
}

type ContractInitialized {
  moduleRef: String!
  contractAddress: ContractAddress!
  amount: UnsignedLong!
  initName: String!
  eventsAsHex("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): StringConnection
}

type ContractModuleDeployed {
  moduleRef: String!
}

type ContractUpdated {
  contractAddress: ContractAddress!
  instigator: Address!
  amount: UnsignedLong!
  messageAsHex: String!
  receiveName: String!
  eventsAsHex("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): StringConnection
}

type CredentialDeployed {
  regId: String!
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type CredentialDeploymentTransaction {
  credentialDeploymentTransactionType: CredentialDeploymentTransactionType
}

type CredentialHolderDidNotSign {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type CredentialKeysUpdated {
  credId: String!
}

type CredentialsUpdated {
  accountAddress: AccountAddress!
  newCredIds: [String!]!
  removedCredIds: [String!]!
  newThreshold: Byte!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type DataRegistered {
  dataAsHex: String!
}

type DecodedTransferMemo {
  text: String!
  decodeType: TextDecodeType!
}

type DuplicateAggregationKey {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  aggregationKey: String!
}

type DuplicateCredIds {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  credIds: [String!]!
}

type ElectionDifficultyChainUpdatePayload {
  electionDifficulty: Decimal!
}

type EncryptedAmountSelfTransfer {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type EncryptedAmountsRemoved {
  accountAddress: AccountAddress!
  newEncryptedAmount: String!
  inputAmount: String!
  upToIndex: UnsignedLong!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type EncryptedSelfAmountAdded {
  accountAddress: AccountAddress!
  newEncryptedAmount: String!
  amount: UnsignedLong!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type EuroPerEnergyChainUpdatePayload {
  exchangeRate: ExchangeRate!
}

"A connection to a list of items."
type EventsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [EventsEdge!]
  "A flattened list of the nodes."
  nodes: [Event!]
  totalCount: Int!
}

"An edge in a connection."
type EventsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Event!
}

type ExchangeRate {
  numerator: UnsignedLong!
  denominator: UnsignedLong!
}

type FinalizationReward {
  amount: UnsignedLong!
  address: AccountAddress!
  addressString: String! @deprecated(reason: "Use 'address.asString' instead. This field will be removed in the near future.")
}

"A connection to a list of items."
type FinalizationRewardConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [FinalizationRewardEdge!]
  "A flattened list of the nodes."
  nodes: [FinalizationReward!]
}

"An edge in a connection."
type FinalizationRewardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: FinalizationReward!
}

type FinalizationRewards {
  rewards("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): FinalizationRewardConnection
  remainder: UnsignedLong!
}

type FinalizationSummary {
  finalizers("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): FinalizersConnection
  finalizedBlockHash: String!
  finalizationIndex: Long!
  finalizationDelay: Long!
}

type FinalizationSummaryParty {
  bakerId: Long!
  weight: Long!
  signed: Boolean!
}

"A connection to a list of items."
type FinalizersConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [FinalizersEdge!]
  "A flattened list of the nodes."
  nodes: [FinalizationSummaryParty!]
}

"An edge in a connection."
type FinalizersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: FinalizationSummaryParty!
}

type FirstScheduledReleaseExpired {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type FoundationAccountChainUpdatePayload {
  accountAddress: AccountAddress!
}

type GasRewards {
  baker: Decimal!
  finalizationProof: Decimal!
  accountCreation: Decimal!
  chainUpdate: Decimal!
}

type GasRewardsChainUpdatePayload {
  baker: Decimal!
  finalizationProof: Decimal!
  accountCreation: Decimal!
  chainUpdate: Decimal!
}

type InsufficientBalanceForBakerStake {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidAccountReference {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type InvalidAccountThreshold {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidContractAddress {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  contractAddress: ContractAddress!
}

type InvalidCredentialKeySignThreshold {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidCredentials {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidEncryptedAmountTransferProof {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidIndexOnEncryptedTransfer {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidInitMethod {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  moduleRef: String!
  initName: String!
}

type InvalidModuleReference {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  moduleRef: String!
}

type InvalidProof {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type InvalidReceiveMethod {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  moduleRef: String!
  receiveName: String!
}

type InvalidTransferToPublicProof {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type KeyIndexAlreadyInUse {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type Level1KeysChainUpdatePayload {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema since graphql does not allow types without any fields")
}

type MicroCcdPerEuroChainUpdatePayload {
  exchangeRate: ExchangeRate!
}

type Mint {
  bakingReward: UnsignedLong!
  finalizationReward: UnsignedLong!
  platformDevelopmentCharge: UnsignedLong!
  foundationAccount: String! @deprecated(reason: "Use 'foundationAccountAddress' instead.This field will be removed in the near future.")
  foundationAccountAddress: AccountAddress!
}

type MintDistribution {
  mintPerSlot: Decimal!
  bakingReward: Decimal!
  finalizationReward: Decimal!
}

type MintDistributionChainUpdatePayload {
  mintPerSlot: Decimal!
  bakingReward: Decimal!
  finalizationReward: Decimal!
}

type ModuleHashAlreadyExists {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  moduleRef: String!
}

type ModuleNotWf {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type NewEncryptedAmount {
  accountAddress: AccountAddress!
  newIndex: UnsignedLong!
  encryptedAmount: String!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type NonExistentCredIds {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  credIds: [String!]!
}

type NonExistentCredentialId {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type NonExistentRewardAccount {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type NonIncreasingSchedule {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type NotABaker {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type NotAllowedMultipleCredentials {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type NotAllowedToHandleEncrypted {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type NotAllowedToReceiveEncrypted {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type OutOfEnergy {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type ProtocolChainUpdatePayload {
  message: String!
  specificationUrl: String!
  specificationHash: String!
  specificationAuxiliaryDataAsHex: String!
}

type Query {
  block(id: ID!): Block
  blockByBlockHash(blockHash: String!): Block
  blocks("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): BlocksConnection
  transaction(id: ID!): Transaction
  transactionByTransactionHash(transactionHash: String!): Transaction
  transactions("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): TransactionsConnection
  account(id: ID!): Account
  accountByAddress(accountAddress: String!): Account
  accounts(sort: AccountSort! = AGE_DESC "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): AccountsConnection
  search(query: String!): SearchResult!
  blockMetrics(period: MetricsPeriod!): BlockMetrics
  transactionMetrics(period: MetricsPeriod!): TransactionMetrics
  accountsMetrics(period: MetricsPeriod!): AccountsMetrics
}

type Rejected {
  reason: TransactionRejectReason!
}

type RejectedInit {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  rejectReason: Int!
}

type RejectedReceive {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  rejectReason: Int!
  contractAddress: ContractAddress!
  receiveName: String!
  messageAsHex: String!
}

type RemoveFirstCredential {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type RewardParameters {
  mintDistribution: MintDistribution!
  transactionFeeDistribution: TransactionFeeDistribution!
  gasRewards: GasRewards!
}

type RootKeysChainUpdatePayload {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema since graphql does not allow types without any fields")
}

type RuntimeFailure {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type ScheduledSelfTransfer {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
  accountAddress: AccountAddress!
  accountAddressString: String! @deprecated(reason: "Use 'accountAddress.asString' instead. This field will be removed in the near future.")
}

type SearchResult {
  blocks("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): BlocksConnection
  transactions("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): TransactionsConnection
  accounts("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): AccountsConnection
}

type SerializationFailure {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

type SpecialEvents {
  mint: Mint
  finalizationRewards: FinalizationRewards
  blockRewards: BlockRewards
  bakingRewards: BakingRewards
}

type StakeUnderMinimumThresholdForBaking {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

"A connection to a list of items."
type StringConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [StringEdge!]
  "A flattened list of the nodes."
  nodes: [String!]
}

"An edge in a connection."
type StringEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: String!
}

type Subscription {
  blockAdded: Block!
}

type Success {
  events("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): EventsConnection
}

type TimestampedAmount {
  timestamp: DateTime!
  amount: UnsignedLong!
}

type Transaction {
  block: Block!
  id: ID!
  transactionIndex: Int!
  transactionHash: String!
  senderAccountAddress: AccountAddress
  senderAccountAddressString: String @deprecated(reason: "Use 'senderAccountAddress.asString' instead. This field will be removed in the near future.")
  ccdCost: UnsignedLong!
  energyCost: UnsignedLong!
  transactionType: TransactionType!
  result: TransactionResult!
}

type TransactionFeeDistribution {
  baker: Decimal!
  gasAccount: Decimal!
}

type TransactionFeeDistributionChainUpdatePayload {
  baker: Decimal!
  gasAccount: Decimal!
}

type TransactionMetrics {
  "Total number of transactions (all time)"
  lastCumulativeTransactionCount: Long!
  "Total number of transactions in requested period."
  transactionCount: Int!
  buckets: TransactionMetricsBuckets!
}

type TransactionMetricsBuckets {
  "The width (time interval) of each bucket."
  bucketWidth: TimeSpan!
  "Start of the bucket time period. Intended x-axis value."
  x_Time: [DateTime!]!
  "Total number of transactions (all time) at the end of the bucket period. Intended y-axis value."
  y_LastCumulativeTransactionCount: [Long!]!
  "Total number of transactions within the bucket time period. Intended y-axis value."
  y_TransactionCount: [Int!]!
}

"A connection to a list of items."
type TransactionsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [TransactionsEdge!]
  "A flattened list of the nodes."
  nodes: [Transaction!]
}

"An edge in a connection."
type TransactionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Transaction!
}

type TransferMemo {
  decoded: DecodedTransferMemo!
  rawHex: String!
}

type Transferred {
  amount: UnsignedLong!
  from: Address!
  to: Address!
}

type TransferredWithSchedule {
  fromAccountAddress: AccountAddress!
  toAccountAddress: AccountAddress!
  amountsSchedule("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): AmountsScheduleConnection
  fromAccountAddressString: String! @deprecated(reason: "Use 'fromAccountAddress.asString' instead. This field will be removed in the near future.")
  toAccountAddressString: String! @deprecated(reason: "Use 'toAccountAddress.asString' instead. This field will be removed in the near future.")
  totalAmount: UnsignedLong!
}

type UpdateTransaction {
  updateTransactionType: UpdateTransactionType
}

type ZeroScheduledAmount {
  _: Boolean! @deprecated(reason: "Don't use! This field is only in the schema to make sure reject reasons without any fields are valid types in GraphQL (which does not allow types without any fields)")
}

union Address = AccountAddress | ContractAddress

union BlockOrTransaction = Block | Transaction

union ChainUpdatePayload = ProtocolChainUpdatePayload | ElectionDifficultyChainUpdatePayload | EuroPerEnergyChainUpdatePayload | MicroCcdPerEuroChainUpdatePayload | FoundationAccountChainUpdatePayload | MintDistributionChainUpdatePayload | TransactionFeeDistributionChainUpdatePayload | GasRewardsChainUpdatePayload | BakerStakeThresholdChainUpdatePayload | RootKeysChainUpdatePayload | Level1KeysChainUpdatePayload | AddAnonymityRevokerChainUpdatePayload | AddIdentityProviderChainUpdatePayload

union Event = Transferred | AccountCreated | AmountAddedByDecryption | BakerAdded | BakerKeysUpdated | BakerRemoved | BakerSetRestakeEarnings | BakerStakeDecreased | BakerStakeIncreased | ContractInitialized | ContractModuleDeployed | ContractUpdated | CredentialDeployed | CredentialKeysUpdated | CredentialsUpdated | DataRegistered | EncryptedAmountsRemoved | EncryptedSelfAmountAdded | NewEncryptedAmount | TransferMemo | TransferredWithSchedule | ChainUpdateEnqueued

union TransactionRejectReason = ModuleNotWf | ModuleHashAlreadyExists | InvalidAccountReference | InvalidInitMethod | InvalidReceiveMethod | InvalidModuleReference | InvalidContractAddress | RuntimeFailure | AmountTooLarge | SerializationFailure | OutOfEnergy | RejectedInit | RejectedReceive | NonExistentRewardAccount | InvalidProof | AlreadyABaker | NotABaker | InsufficientBalanceForBakerStake | StakeUnderMinimumThresholdForBaking | BakerInCooldown | DuplicateAggregationKey | NonExistentCredentialId | KeyIndexAlreadyInUse | InvalidAccountThreshold | InvalidCredentialKeySignThreshold | InvalidEncryptedAmountTransferProof | InvalidTransferToPublicProof | EncryptedAmountSelfTransfer | InvalidIndexOnEncryptedTransfer | ZeroScheduledAmount | NonIncreasingSchedule | FirstScheduledReleaseExpired | ScheduledSelfTransfer | InvalidCredentials | DuplicateCredIds | NonExistentCredIds | RemoveFirstCredential | CredentialHolderDidNotSign | NotAllowedMultipleCredentials | NotAllowedToReceiveEncrypted | NotAllowedToHandleEncrypted

union TransactionResult = Success | Rejected

union TransactionType = AccountTransaction | CredentialDeploymentTransaction | UpdateTransaction

enum AccountSort {
  AGE_ASC
  AGE_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  TRANSACTION_COUNT_ASC
  TRANSACTION_COUNT_DESC
}

enum AccountStatementEntryType {
  TRANSFER_IN
  TRANSFER_OUT
  AMOUNT_DECRYPTED
  AMOUNT_ENCRYPTED
  TRANSACTION_FEE
  BAKING_REWARD
  BLOCK_REWARD
  FINALIZATION_REWARD
  MINT_REWARD
}

enum AccountTransactionType {
  DEPLOY_MODULE
  INITIALIZE_SMART_CONTRACT_INSTANCE
  UPDATE_SMART_CONTRACT_INSTANCE
  SIMPLE_TRANSFER
  ADD_BAKER
  REMOVE_BAKER
  UPDATE_BAKER_STAKE
  UPDATE_BAKER_RESTAKE_EARNINGS
  UPDATE_BAKER_KEYS
  UPDATE_CREDENTIAL_KEYS
  ENCRYPTED_TRANSFER
  TRANSFER_TO_ENCRYPTED
  TRANSFER_TO_PUBLIC
  TRANSFER_WITH_SCHEDULE
  UPDATE_CREDENTIALS
  REGISTER_DATA
  SIMPLE_TRANSFER_WITH_MEMO
  ENCRYPTED_TRANSFER_WITH_MEMO
  TRANSFER_WITH_SCHEDULE_WITH_MEMO
}

enum CredentialDeploymentTransactionType {
  INITIAL
  NORMAL
}

enum MetricsPeriod {
  LAST_HOUR
  LAST24_HOURS
  LAST7_DAYS
  LAST30_DAYS
  LAST_YEAR
}

enum TextDecodeType {
  CBOR
  HEX
}

enum UpdateTransactionType {
  UPDATE_PROTOCOL
  UPDATE_ELECTION_DIFFICULTY
  UPDATE_EURO_PER_ENERGY
  UPDATE_MICRO_GTU_PER_EURO
  UPDATE_FOUNDATION_ACCOUNT
  UPDATE_MINT_DISTRIBUTION
  UPDATE_TRANSACTION_FEE_DISTRIBUTION
  UPDATE_GAS_REWARDS
  UPDATE_BAKER_STAKE_THRESHOLD
  UPDATE_ADD_ANONYMITY_REVOKER
  UPDATE_ADD_IDENTITY_PROVIDER
  UPDATE_ROOT_KEYS
  UPDATE_LEVEL1_KEYS
  UPDATE_LEVEL2_KEYS
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String "Deferred when true." if: Boolean) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String "The initial elements that shall be send down to the consumer." initialCount: Int! = 0 "Streamed when true." if: Boolean) on FIELD

"The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255."
scalar Byte

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The built-in `Decimal` scalar type."
scalar Decimal

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `TimeSpan` scalar represents an ISO-8601 compliant duration type."
scalar TimeSpan

"The UnsignedLong scalar type represents a unsigned 64-bit numeric non-fractional value greater than or equal to 0."
scalar UnsignedLong
